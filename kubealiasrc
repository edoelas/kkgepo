alias python='python3'
alias pip='pip3'

export KUBECONFIG=$(find ~/.kube -type f -name 'config_*' | tr '\n' ':')

shopt -s extdebug # para usar preexec sin que muestre command not found

preexec() {
    if [[ $1 == kk* ]]; then

        local command="${1:2}"
        first_element="${command%% *}"

        # Extract the rest of the elements
        if [[ "$command" == *" "* ]]; then
            rest_elements="${command#* }"
        else
            rest_elements=""
        fi
        eval $(python ~/kkgepo/kubealias.py $first_element) ${rest_elements} ;
        return 1
    fi
}

trap 'preexec "$BASH_COMMAND"' DEBUG # alternativa palera a instalar bash-preexec

# La versiÃ³n de arriba mola mas, pero si no se quiere usar preexec, se puede usar esta
function ku(){
    eval $(python ~/kubealias/kubealias.py $1) ${@:2} ;
    # echo $(python ~/kubealias.py $1);
}

# namespace get and set
function ksens() { kubectl config set-context --current --namespace="$1";}
function kgens() { kubectl config view --minify --output 'jsonpath={..namespace}' | tr -d "\n"; echo; } # if empty, it's in default namespace

function ksetns() {
    local current_ns=$(kgens)
    local new_ns=$(ku gens --no-headers | fzf --header="current: $current_ns" | echo $(awk '{print $1}') )
    ksens $new_ns
}

# context get and set
function ksetco(){
    local current_context=$(kubectl config current-context)
    local context=$(kubectl config get-contexts --no-headers | fzf --header="current: $current_context" | awk '{print $1}')
    kubectl config use-context $context
}

# if code is available, use it as the editor, else use vim
if code -v >/dev/null 2>&1; then
    export KUBE_EDITOR="code --wait"
else
    export KUBE_EDITOR="vi"
fi